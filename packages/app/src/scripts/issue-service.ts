/* Issue creation UI + backend integration (feature-flag aware) */
import { ApiClient } from './api-client';

interface ComplianceIssue { id: string; message: string; severity?: string; error?: string; }
interface ReportData {
  repoUrl: string;
  compliance: { issues: ComplianceIssue[]; compliant: any[]; summary?: string };
  ruleSet?: string;
  customConfig?: { gistUrl?: string };
  upstreamTemplate?: string;
  upstream?: string;
}

function getReportData(): ReportData | undefined {
  return (window as any).reportData;
}

function notification(){
  return (window as any).NotificationSystem || (window as any).Notifications;
}

function showWarn(title: string, msg: string){
  const n = notification();
  if(!n) return console.warn(title+': '+msg);
  if (n.showWarning) n.showWarning(title,msg,7000); else if (n.warning) n.warning(title,msg); else console.warn(title+': '+msg);
}
function showError(title: string, msg: string){
  const n = notification();
  if(!n) return console.error(title+': '+msg);
  if (n.showError) n.showError(title,msg,10000); else if (n.error) n.error(title,msg); else console.error(title+': '+msg);
}
function showInfo(title: string, msg: string){
  const n = notification();
  if(!n) return console.log(title+': '+msg);
  if (n.showInfo) n.showInfo(title,msg,5000); else if (n.info) n.info(title,msg); else console.log(title+': '+msg);
}

function confirmCreate(cb: ()=>void){
  const n = notification();
  if(n?.confirm){
    n.confirm('Create GitHub Issues','This will create GitHub issues for all compliance problems. Proceed?',{confirmLabel:'Create',cancelLabel:'Cancel',onConfirm:cb});
  } else if (window.confirm('Create GitHub issues for all problems?')) cb();
}

function parseOwnerRepo(url: string){
  try { const u = new URL(url); const parts = u.pathname.split('/'); if(parts.length>=3) return { owner: parts[1], repo: parts[2] }; } catch {}
  return { owner: undefined, repo: undefined };
}

function capitalizeFirst(s: string){ return s ? s.charAt(0).toUpperCase()+s.slice(1) : s; }

function mapSeverity(sev?: string): 'high'|'medium'|'low' {
  if(!sev) return 'low';
  const lower = sev.toLowerCase();
  if(lower === 'error' || lower === 'critical') return 'high';
  if(lower === 'warning' || lower === 'warn') return 'medium';
  return 'low';
}

function buildMainIssueBody(data: ReportData){
  const issues = data.compliance?.issues || [];
  const ruleSet = data.ruleSet || 'dod';
  const ruleSetCap = capitalizeFirst(ruleSet);
  const sevCounts = { high:0, medium:0, low:0 };
  issues.forEach(i=>{ sevCounts[mapSeverity(i.severity)]++; });
  // Build body with required sections for tests
  let body = '# Template Doctor Analysis\n\n';
  body += `Repo: ${data.repoUrl}\n`;
  body += '## Configuration\n';
  if(ruleSet === 'custom' && data.customConfig?.gistUrl){
    body += `Rule Set: ${ruleSetCap} (custom from ${data.customConfig.gistUrl})\n`;
  } else {
    body += `Rule Set: ${ruleSetCap}\n`;
  }
  body += `Severity Breakdown: High ${sevCounts.high}, Medium ${sevCounts.medium}, Low ${sevCounts.low}\n\n`;
  if(issues.length){
    body += '## Issues to Fix\n';
    issues.forEach((it,i)=>{ body += `${i+1}. **${it.message}**${it.error?` - ${it.error}`:''}\n`; });
  }
  body += '\n---\n*Generated by Template Doctor*';
  return body;
}

function buildChildIssueBody(mainTitle: string, issue: ComplianceIssue, data: ReportData){
  const sev = mapSeverity(issue.severity);
  const ruleSet = data.ruleSet || 'dod';
  const ruleSetCap = capitalizeFirst(ruleSet);
  let body = `Child issue of: ${mainTitle}\n\n`;
  body += `## Context\n`;
  body += `Severity: ${capitalizeFirst(sev)}\n`;
  if(ruleSet === 'custom' && data.customConfig?.gistUrl){
    body += `Rule Set: ${ruleSetCap} (custom from ${data.customConfig.gistUrl})\n`;
  } else {
    body += `Rule Set: ${ruleSetCap}\n`;
  }
  body += `Problem: ${issue.message}\n`;
  if(issue.error) body += `Details: ${issue.error}\n`;
  body += '\n---\n*Generated by Template Doctor*';
  return body;
}

async function createIssues(){
  const data = getReportData();
  if(!data){ return showError('Error','No report data'); }
  const { owner, repo } = parseOwnerRepo(data.repoUrl);
  if(!owner || !repo){ return showError('Error','Cannot parse repository owner/repo'); }
  const issues = data.compliance?.issues || [];
  const ruleSet = data.ruleSet || 'dod';
  const today = new Date().toISOString().split('T')[0];
  const summary = data.compliance?.summary || 'Template Doctor Analysis';
  const issueTitle = `Template Doctor Analysis: ${summary} [${today}]`;
  const body = buildMainIssueBody(data);

  const baseLabels = (window as any).GITHUB_LABELS && Array.isArray((window as any).GITHUB_LABELS) ? (window as any).GITHUB_LABELS : ['template-doctor','template-doctor-full-scan'];
  const rulesetLabel = `ruleset:${ruleSet}`;
  const severityFamily = ['severity:high','severity:medium','severity:low'];
  const mainLabels = Array.from(new Set([...baseLabels, rulesetLabel, ...severityFamily]));

  let button = document.getElementById('create-github-issue-btn') as HTMLButtonElement | null;
  const restore = button ? prepButtonLoading(button,'Creating Issues...') : () => {};
  try {
    // Build child issue descriptors for backend (now supported). Keep client-only creation in legacy shim.
    const childIssues = issues.map(c => {
      const sev = mapSeverity(c.severity);
      return {
        title: c.message,
        body: buildChildIssueBody(issueTitle, c, data),
        labels: ['template-doctor','template-doctor-child-issue', rulesetLabel, `severity:${sev}`]
      };
    });
  const main = await ApiClient.createIssue({ owner, repo, title: issueTitle, body, labels: mainLabels, assignCopilot: true, childIssues });
  const childCount = main.childResults ? main.childResults.filter(c=>c.issueNumber).length : 0;
  const childFailures = main.childResults ? main.childResults.filter(c=>c.error).length : 0;
  const childFragment = childCount || childFailures ? ` (children: ${childCount} ok${childFailures?`, ${childFailures} failed`:''})` : '';
  showInfo('Issue Created', `#${main.issueNumber} created${childFragment}`);
    document.dispatchEvent(new CustomEvent('issue-created',{ detail: { number: main.issueNumber, url: main.htmlUrl }}));
  } catch(e:any){
    showError('Issue Creation Failed', e.message||String(e));
  } finally { restore(); }
}

function prepButtonLoading(btn: HTMLButtonElement, label: string){
  const original = btn.innerHTML; btn.disabled = true; btn.innerHTML = `<i class="fas fa-spinner fa-spin"></i> ${label}`;
  return () => { btn.disabled = false; btn.innerHTML = original; };
}

export function wireIssueButton(){
  const btn = document.getElementById('create-github-issue-btn');
  if(!btn) return;
  btn.addEventListener('click', ()=>{
    confirmCreate(()=> createIssues());
  }, { once: true });
}

// Auto-wire when report loads
if (typeof document !== 'undefined'){
  document.addEventListener('template-report-rendered', ()=> wireIssueButton());
}

// Expose
(window as any).TemplateDoctorIssueService = { wireIssueButton, createIssues };

document.addEventListener('issue-service-ready', ()=>{});

// ---------------- Legacy Compatibility Shim for existing tests -----------------
// Re-implements a subset of legacy logic (labels + body + child issues) in TS.
async function processIssueCreation(github: any){
  const data = getReportData();
  if(!data) return;
  const { owner, repo } = parseOwnerRepo(data.repoUrl);
  if(!owner || !repo) return;
  const issues = data.compliance?.issues || [];
  const ruleSet = data.ruleSet || 'dod';
  const today = new Date().toISOString().split('T')[0];
  const summary = data.compliance?.summary || 'Template Doctor Analysis';
  const issueTitle = `Template Doctor Analysis: ${summary} [${today}]`;
  const rulesetLabel = `ruleset:${ruleSet}`;
  const severityFamily = ['severity:high','severity:medium','severity:low'];
  const baseLabels = (window as any).GITHUB_LABELS && Array.isArray((window as any).GITHUB_LABELS) ? (window as any).GITHUB_LABELS : ['template-doctor','template-doctor-full-scan'];
  const mainLabels = Array.from(new Set([...baseLabels, rulesetLabel, ...severityFamily]));
  try {
    // Ensure label family (legacy test captures this)
    if(github.ensureLabelsExist){
      await github.ensureLabelsExist(owner, repo, mainLabels);
    }
    const mainBody = buildMainIssueBody(data);
    const mainIssue = await github.createIssueGraphQL(owner, repo, issueTitle, mainBody, mainLabels);
    // Create child issues for each compliance issue
    for(const c of issues){
      const sev = mapSeverity(c.severity);
      const childLabels = ['template-doctor','template-doctor-child-issue', `ruleset:${ruleSet}`, `severity:${sev}`];
      const childBody = buildChildIssueBody(issueTitle, c, data);
      if(github.createIssueWithoutCopilot){
        await github.createIssueWithoutCopilot(owner, repo, c.message, childBody, childLabels);
      } else if (github.createIssueGraphQL){
        await github.createIssueGraphQL(owner, repo, c.message, childBody, childLabels);
      }
    }
    return mainIssue;
  } catch (e){
    console.error('processIssueCreation failed', e);
  }
}

function createGitHubIssue(){
  // Minimal wrapper to keep API parity with legacy if still referenced.
  if((window as any).GitHubClient){
    processIssueCreation((window as any).GitHubClient);
  }
}

(window as any).processIssueCreation = processIssueCreation;
(window as any).createGitHubIssue = createGitHubIssue;
