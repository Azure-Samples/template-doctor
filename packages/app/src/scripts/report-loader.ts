// @ts-nocheck
// Migrated from js/report-loader.js (behavior preserved)
console.log('Loading report-loader.ts');
(function(){
  if ((window as any).ReportLoader !== undefined){ console.log('ReportLoader already exists, skipping'); return; }
  function ReportLoaderClass(){
    this.debug = function(message, data){ if (typeof (window as any).debug === 'function') { (window as any).debug('report-loader', message, data); } else { console.log(`[ReportLoader] ${message}`, data !== undefined ? data : ''); } };
    this.loadReport = async function(repoUrl, options = {}){ this.debug('loadReport called', { repoUrl, options }); try { if (!repoUrl) throw new Error('Repository URL is required'); const reportContainer = document.getElementById('report'); if (!reportContainer){ this.debug('Report container not found'); return { success: false, error: 'Report container not found' }; } reportContainer.innerHTML = '<div class="loading-message">Loading report...</div>'; const data = await this.fetchReportData(repoUrl, options); if (!data){ reportContainer.innerHTML = '<div class="error-message">No report data available</div>'; return { success: false, error: 'No data' }; }
        // Provide alias for legacy scripts
        (window as any).reportDataOriginal = data;
        if ((window as any).DashboardRenderer){ (window as any).DashboardRenderer.render(data, reportContainer); return { success: true, data }; } else { reportContainer.innerHTML = '<div class="error-message">Dashboard renderer not available</div>'; return { success: false, error: 'Dashboard renderer not available' }; }
      } catch (e){ console.error('Error loading report:', e); const reportContainer = document.getElementById('report'); if (reportContainer){ reportContainer.innerHTML = `<div class="error-message">Error loading report: ${e.message}</div>`; } return { success: false, error: e.message }; } };
    this.fetchReportData = async function(repoUrl, options = {}){ this.debug('fetchReportData called', { repoUrl, options }); const strategies = [ this.tryLatestJson.bind(this), this.tryTimestampedJson.bind(this), this.tryEmbeddedScript.bind(this) ]; for (const strat of strategies){ try { const data = await strat(repoUrl, options); if (data){ this.debug('Data loaded via strategy', strat.name); return data; } } catch (e){ this.debug('Strategy failed', { name: strat.name, error: e.message }); } } this.debug('All strategies failed'); return null; };
    this.tryLatestJson = async function(repoUrl){ try { const folder = this.getResultsFolderForRepo(repoUrl); if (!folder) return null; const url = `/results/${folder}/latest.json`; this.debug('Trying latest.json', url); const resp = await fetch(url, { cache: 'no-store' }); if (!resp.ok) throw new Error(`HTTP ${resp.status}`); const data = await resp.json(); if (!data || typeof data !== 'object') return null; if (!data.analyzerVersion){ data.analyzerVersion = 'unknown'; } return data; } catch (e){ this.debug('tryLatestJson failed', e.message); return null; } };
    this.tryTimestampedJson = async function(repoUrl){ try { const folder = this.getResultsFolderForRepo(repoUrl); if (!folder) return null; const url = `/results/${folder}`; this.debug('Trying timestamped JSON in folder', url); const listing = await fetch(url, { cache: 'no-store' }); if (!listing.ok) throw new Error(`HTTP ${listing.status}`); const html = await listing.text(); const matches = [...html.matchAll(/href="(\d{4}-\d{2}-\d{2}T\d{6}Z\.json)"/g)]; if (matches.length === 0) return null; matches.sort((a,b)=> b[1].localeCompare(a[1])); for (const m of matches){ const file = m[1]; try { const fileUrl = `${url}/${file}`; const resp = await fetch(fileUrl, { cache: 'no-store' }); if (!resp.ok) continue; const data = await resp.json(); if (data && typeof data === 'object'){ if (!data.analyzerVersion){ data.analyzerVersion = 'unknown'; } return data; } } catch (_){} } return null; } catch(e){ this.debug('tryTimestampedJson failed', e.message); return null; } };
    this.tryEmbeddedScript = async function(repoUrl){ try { const scriptEl = document.getElementById('report-data-script'); if (!scriptEl) return null; this.debug('Trying embedded script data'); const text = scriptEl.textContent || scriptEl.innerText; if (!text) return null; const jsonStart = text.indexOf('{'); if (jsonStart === -1) return null; const jsonText = text.slice(jsonStart); const data = JSON.parse(jsonText); if (!data.analyzerVersion){ data.analyzerVersion = 'unknown'; } return data; } catch(e){ this.debug('tryEmbeddedScript failed', e.message); return null; } };
    this.getResultsFolderForRepo = function(repoUrl){ if (!repoUrl) return null; try { if (Array.isArray((window as any).templatesData)){ const match = (window as any).templatesData.find((t)=>{ const a = String(t.repoUrl || '').replace(/\.git$/, '').toLowerCase(); const b = String(repoUrl).replace(/\.git$/, '').toLowerCase(); return a===b; }); if (match && match.relativePath){ const folder = match.relativePath.split('/')[0]; if (folder) return folder; } } const u = new URL(repoUrl); const parts = u.pathname.split('/').filter(Boolean); if (parts.length >= 2){ return `${parts[0]}-${parts[1]}`.toLowerCase(); } } catch(e){ this.debug('getResultsFolderForRepo error', e.message); } return null; };
  }
  (window as any).ReportLoader = new ReportLoaderClass();
})();
export {};