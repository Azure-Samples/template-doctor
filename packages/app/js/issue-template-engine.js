// Issue Template Engine
// Provides structured issue title/body generation for Template Doctor violations.
// Goal: produce consistent, Copilot-friendly issue descriptions with rich metadata.

(function () {
  const DEFAULT_SEVERITY_LABELS = {
    error: 'High',
    warning: 'Medium',
    info: 'Low',
    low: 'Low',
  };

  // Optional per-rule template overrides. Key = rule id (string or prefix matcher via function).
  // Each value can be a function(issue, ctx) => { title, body } or an object with markdown fragments.
  const RULE_TEMPLATES = {
    // Example static rule template (can be extended by contributors):
    // 'missing-readme': (issue, ctx) => ({
    //   title: `Add a README.md to document the project [${issue.id}]`,
    //   body: ctx.buildStandardBody(issue, ctx, {
    //     summary: 'The repository does not include a README.md which is required for discoverability.',
    //     acceptance: [
    //       'Root README.md exists',
    //       'Contains project overview',
    //       'Provides quickstart instructions',
    //       'Includes license & contribution guidance',
    //     ],
    //   }),
    // })
  };

  // Helper to safely stringify JSON for embedding in HTML comments
  function serializeMeta(meta) {
    try {
      return JSON.stringify(meta, null, 2).replace(/</g, '\\u003c');
    } catch {
      return '{}';
    }
  }

  // Potential future hook for AI model enrichment (stub)
  async function maybeGenerateWithModel(base, meta, ctx) {
    if (!window.ENABLE_ISSUE_AI) return base; // simple flag gate
    if (typeof window.CustomIssueAIProvider === 'function') {
      try {
        const enriched = await window.CustomIssueAIProvider(base, meta, ctx);
        if (enriched && typeof enriched.body === 'string') return enriched;
      } catch (e) {
        console.warn('[IssueTemplateEngine] AI provider failed, falling back to base template', e);
      }
    }
    return base;
  }

  // Core builder for standardized markdown body
  function buildStandardBody(issue, ctx, overrides = {}) {
    const severityDisplay = ctx.severityDisplay;
    const lines = [];
    lines.push(`# ${issue.message}`);
    lines.push('');
    if (overrides.summary) {
      lines.push('## Summary');
      lines.push('');
      lines.push(overrides.summary.trim());
      lines.push('');
    } else if (issue.error) {
      lines.push('## Details');
      lines.push('');
      lines.push(issue.error.trim());
      lines.push('');
    }

    // Problem Statement
    lines.push('## Problem');
    lines.push('');
    lines.push(overrides.problem || 'This repository does not meet one of the required template rules.');
    lines.push('');

    // Impact
    lines.push('## Impact');
    lines.push('');
    lines.push(
      overrides.impact ||
        'Leaving this unresolved can reduce template reliability, developer experience, or automation effectiveness.',
    );
    lines.push('');

    // Recommended Fix
    lines.push('## Recommended Fix');
    lines.push('');
    lines.push(
      overrides.fix ||
        inferGenericFix(issue),
    );
    lines.push('');

    // Acceptance Criteria
    if (overrides.acceptance && Array.isArray(overrides.acceptance) && overrides.acceptance.length) {
      lines.push('## Acceptance Criteria');
      lines.push('');
      overrides.acceptance.forEach((c) => lines.push(`- [ ] ${c}`));
      lines.push('');
    }

    // Context / metadata for humans
    lines.push('## Context');
    lines.push('');
    lines.push(`- Rule ID: ${issue.id}`);
    lines.push(`- Severity: ${severityDisplay}`);
    lines.push(`- Rule Set: ${ctx.ruleSetDisplay}${ctx.customGistUrl ? ` (custom from ${ctx.customGistUrl})` : ''}`);
    if (ctx.mainIssue) lines.push(`- Parent Issue: #${ctx.mainIssue.number}`);
    lines.push('');

    // Hidden machine-readable block for Copilot / automation
    const meta = serializeMeta({
      ruleId: issue.id,
      severity: issue.severity || 'warning',
      severityDisplay,
      ruleSet: ctx.ruleSet,
      parentIssueNumber: ctx.mainIssue ? ctx.mainIssue.number : null,
      analyzerVersion: window.TemplateDoctorVersion || 'unknown',
      timestamp: Date.now(),
    });
    lines.push('<!-- template-doctor:metadata');
    lines.push(meta);
    lines.push('-->');
    lines.push('');
    lines.push(
      '*Generated by Template Doctor issue template engine. Adjust the acceptance criteria if you implement an alternative compliant approach.*',
    );

    return lines.join('\n');
  }

  function inferGenericFix(issue) {
    const id = issue.id || '';
    if (id.includes('missing-file')) return 'Add the required file with appropriate content.';
    if (id.includes('missing-folder')) return 'Create the required folder structure including necessary files.';
    if (id.includes('missing-workflow')) return 'Add the missing GitHub Actions workflow under `.github/workflows/`.';
    if (id.includes('readme')) return 'Update or create `README.md` with required sections (Overview, Prereqs, Getting Started, Resources).';
    if (id.includes('bicep')) return 'Add or update the Bicep resources so required infrastructure components are declared.';
    if (id.includes('azure-yaml')) return 'Update `azure.yaml` to include environment, services, and infra definitions per guidelines.';
    return 'Review the rule documentation and implement the required changes.';
  }

  function resolveRuleTemplate(issue) {
    if (RULE_TEMPLATES[issue.id]) return RULE_TEMPLATES[issue.id];
    // Allow prefix-based templates using keys that end with *
    for (const key of Object.keys(RULE_TEMPLATES)) {
      if (key.endsWith('*')) {
        const prefix = key.slice(0, -1);
        if (issue.id.startsWith(prefix)) return RULE_TEMPLATES[key];
      }
    }
    return null;
  }

  async function generateChildIssue(issue, ctx) {
    const severityRaw = (issue.severity || 'warning').toLowerCase();
    const severityDisplay = DEFAULT_SEVERITY_LABELS[severityRaw] || 'Medium';
    const extendedCtx = { ...ctx, severityDisplay };

    const ruleTemplate = resolveRuleTemplate(issue);
    let draft;
    if (typeof ruleTemplate === 'function') {
      draft = ruleTemplate(issue, {
        ...extendedCtx,
        buildStandardBody: (iss, c, overrides) => buildStandardBody(iss, c, overrides),
      });
    }
    if (!draft) {
      // Default
      draft = {
        title: `${issue.message} [${issue.id}]`,
        body: buildStandardBody(issue, extendedCtx),
      };
    }

    // Allow AI enrichment (returns same shape)
    draft = await maybeGenerateWithModel(draft, { ruleId: issue.id, severity: severityRaw }, extendedCtx);
    return draft;
  }

  window.IssueTemplateEngine = {
    generateChildIssue,
    // expose for custom extension
    _inferGenericFix: inferGenericFix,
    _buildStandardBody: buildStandardBody,
    _ruleTemplates: RULE_TEMPLATES,
  };
})();
